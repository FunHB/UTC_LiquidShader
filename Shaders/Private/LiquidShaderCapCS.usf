/** Copyright 2023, Universal Tool Compiler */

#include "/Engine/Public/Platform.ush"

//Inputs
float LiquidOffset;
uint CapRTSize;

/** SM properties */
float2 BoundRange;
float3 BBOriginPosition;
float3 WorldPosition;
float4 SectionRange[16];
float3 RotationVector;
float RotationAngleCos;
float RotationAngleSin;

/** Buffers */
Buffer<float> VertexBuffer;
Buffer<uint> IndexBuffer;
uint BufferSize;
uint NumTotalVertices;

//Output
RWTexture2D<float4> OutputTexture;

void IntersectionPosition(float3 StartPosition, float3 TargetPositionA, float3 TargetPositionB, out float3 OutA, out float3 OutB)
{
	/** Intersection A */
    float AlphaA = (LiquidOffset - StartPosition.z) / (TargetPositionA.z - StartPosition.z);
    OutA = lerp(StartPosition, TargetPositionA, AlphaA);

	/** Intersection B */
    float AlphaB = (LiquidOffset - StartPosition.z) / (TargetPositionB.z - StartPosition.z);
    OutB = lerp(StartPosition, TargetPositionB, AlphaB);
	
}

void SortVertexArray(in out float3 Vertices[3])
{
    for (int i = 0; i < 2; i++)
    {
        uint MinIdx = i;
		
        for (int j = i + 1; j < 3; j++)
        {
            if (Vertices[j].z < Vertices[MinIdx].z)
                MinIdx = j;
        }

        float3 TempValue = Vertices[MinIdx];
        Vertices[MinIdx] = Vertices[i];
        Vertices[i] = TempValue;
    }
}

bool IsTriangleIntersected(float3 Vertices[3])
{
    if ((Vertices[0].z > LiquidOffset && Vertices[1].z > LiquidOffset && Vertices[2].z > LiquidOffset))
        return false;

    if ((Vertices[0].z < LiquidOffset && Vertices[1].z < LiquidOffset && Vertices[2].z < LiquidOffset))
        return false;

    return true;
}

void PerformIntersection(float3 Vertices[3], out float3 IntersectionA, out float3 IntersectionB)
{
    SortVertexArray(Vertices);
		
    float3 OutA, OutB;
		
    if (Vertices[1].z > LiquidOffset)
        IntersectionPosition(Vertices[0], Vertices[1], Vertices[2], OutA, OutB);
    else
        IntersectionPosition(Vertices[2], Vertices[0], Vertices[1], OutA, OutB);

    IntersectionA = OutA;
    IntersectionB = OutB;
}

float2 Remap2f(float2 InMin, float2 InMax, float2 OutMin, float2 OutMax, float2 InValue)
{
    float2 InRange = InMax - InMin;
    if (InRange.x == 0 && InRange.y == 0)
    {
        return OutMin;
    }
    else
    {
        float2 OutRange = OutMax - OutMin;
        return (((InValue - InMin) * OutRange) / InRange) + OutMin;
    }
}

void DrawLine(float2 DrawStart, float2 DrawEnd, float3 FaceNormal)
{	
    int2 RangedStart = Remap2f(BoundRange.xx, BoundRange.yy, 1, CapRTSize - 2, DrawStart);
    int2 RangedEnd = Remap2f(BoundRange.xx, BoundRange.yy, 1, CapRTSize - 2, DrawEnd);

    if (RangedEnd.x == 0 || RangedEnd.y == 0)
        return;
	
    int Steps;
    float x, y, dx, dy;
    dx = RangedEnd.x - RangedStart.x;
    dy = RangedEnd.y - RangedStart.y;
		
    if (abs(dx) >= abs(dy))
        Steps = abs(dx);
    else
        Steps = abs(dy);
		
    dx = dx / Steps;
    dy = dy / Steps;
		
    x = RangedStart.x;
    y = RangedStart.y;
		
    for (int i = 0; i <= Steps; i++)
    {
        if (OutputTexture[int2(x, y)].x != 0 || OutputTexture[int2(x, y)].y != 0 || OutputTexture[int2(x, y)].z != 0)
        {
            OutputTexture[int2(x, y)] = (OutputTexture[int2(x, y)] + float4(FaceNormal, 1)) / 2;
        }
        else
        {
            OutputTexture[int2(x, y)] = float4(FaceNormal, 1);
        }
		
        x = x + dx;
        y = y + dy;
    }
}

float3 TransformVertex(float3 LocalPosition)
{    
    /** Rotate using axis-angle representation https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation */
    return RotationAngleCos * LocalPosition + RotationAngleSin * cross(RotationVector, LocalPosition) + (1 - RotationAngleCos) * dot(RotationVector, LocalPosition) * RotationVector;
}

void ComputeNormalDirection(float3 Vertices[3], inout float3 NormalDirection)
{    
    NormalDirection = normalize(cross(Vertices[1] - Vertices[0], Vertices[2] - Vertices[0])) * -1;
}

bool CheckInSectionRange(int TriangleIndex)
{
    for (int i = 0; i < 16; i++)
    {
        if (SectionRange[i].x <= TriangleIndex && TriangleIndex <= SectionRange[i].y)
            return true;

        if (SectionRange[i].x == 0 && SectionRange[i].y == 0)
            return false;
    }
	
    return false;
}

[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void MainCS(uint3 ThreadId : SV_DispatchThreadID)
{
    uint TriangleIndex = ThreadId.x * 9;
    uint PositionOffsetA, PositionOffsetB, PositionOffsetC;
    uint PosiitonOffset;
    float3 Normal, IntersectionA, IntersectionB;
    
    float3 Triangle[3];
    
    PositionOffsetA = IndexBuffer[TriangleIndex] * 3;
    PositionOffsetB = IndexBuffer[TriangleIndex + 1] * 3;
    PositionOffsetC = IndexBuffer[TriangleIndex + 2] * 3;
    
    if (CheckInSectionRange(IndexBuffer[TriangleIndex]))
    {           
        Triangle[0] = TransformVertex(float3(
            VertexBuffer[PositionOffsetA],
            VertexBuffer[PositionOffsetA + 1],
            VertexBuffer[PositionOffsetA + 2]
        ));
        Triangle[1] = TransformVertex(float3(
            VertexBuffer[PositionOffsetB],
            VertexBuffer[PositionOffsetB + 1],
            VertexBuffer[PositionOffsetB + 2]
        ));
        Triangle[2] = TransformVertex(float3(
            VertexBuffer[PositionOffsetC],
            VertexBuffer[PositionOffsetC + 1],
            VertexBuffer[PositionOffsetC + 2]
        ));
        
        if (IsTriangleIntersected(Triangle))
        {
            ComputeNormalDirection(Triangle, Normal);
            PerformIntersection(Triangle, IntersectionA, IntersectionB);
            
            DrawLine(IntersectionA.xy, IntersectionB.xy, Normal);
        }
    }
    
    TriangleIndex = TriangleIndex + 3;
    
    PositionOffsetA = IndexBuffer[TriangleIndex] * 3;
    PositionOffsetB = IndexBuffer[TriangleIndex + 1] * 3;
    PositionOffsetC = IndexBuffer[TriangleIndex + 2] * 3;
    
    if (CheckInSectionRange(IndexBuffer[TriangleIndex]))
    {   
        Triangle[0] = TransformVertex(float3(
            VertexBuffer[PositionOffsetA],
            VertexBuffer[PositionOffsetA + 1],
            VertexBuffer[PositionOffsetA + 2]
        ));
        Triangle[1] = TransformVertex(float3(
            VertexBuffer[PositionOffsetB],
            VertexBuffer[PositionOffsetB + 1],
            VertexBuffer[PositionOffsetB + 2]
        ));
        Triangle[2] = TransformVertex(float3(
            VertexBuffer[PositionOffsetC],
            VertexBuffer[PositionOffsetC + 1],
            VertexBuffer[PositionOffsetC + 2]
        ));
        
        if (IsTriangleIntersected(Triangle))
        {
            ComputeNormalDirection(Triangle, Normal);
            PerformIntersection(Triangle, IntersectionA, IntersectionB);
            
            DrawLine(IntersectionA.xy, IntersectionB.xy, Normal);
        }
    }
    
    TriangleIndex = TriangleIndex + 3;
    
    PositionOffsetA = IndexBuffer[TriangleIndex] * 3;
    PositionOffsetB = IndexBuffer[TriangleIndex + 1] * 3;
    PositionOffsetC = IndexBuffer[TriangleIndex + 2] * 3;
    
    if (CheckInSectionRange(IndexBuffer[TriangleIndex]))
    {
        Triangle[0] = TransformVertex(float3(
            VertexBuffer[PositionOffsetA],
            VertexBuffer[PositionOffsetA + 1],
            VertexBuffer[PositionOffsetA + 2]
        ));
        Triangle[1] = TransformVertex(float3(
            VertexBuffer[PositionOffsetB],
            VertexBuffer[PositionOffsetB + 1],
            VertexBuffer[PositionOffsetB + 2]
        ));
        Triangle[2] = TransformVertex(float3(
            VertexBuffer[PositionOffsetC],
            VertexBuffer[PositionOffsetC + 1],
            VertexBuffer[PositionOffsetC + 2]
        ));

        if (IsTriangleIntersected(Triangle))
        {
            ComputeNormalDirection(Triangle, Normal);
            PerformIntersection(Triangle, IntersectionA, IntersectionB);
            
            DrawLine(IntersectionA.xy, IntersectionB.xy, Normal);
        }
    }
}